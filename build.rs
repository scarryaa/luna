use std::{env, fs, path::PathBuf};

use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};

fn main() -> Result<()> {
    println!("cargo:rerun-if-changed=tokens.yaml");

    let manifest_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR")?);
    let yaml_src = fs::read_to_string(manifest_dir.join("tokens.yaml"))
        .with_context(|| "reading tokens.yaml")?;

    let raw: RawTokens = serde_yaml::from_str(&yaml_src).with_context(|| "parsing YAML")?;

    let out_dir = PathBuf::from(env::var("OUT_DIR")?);
    fs::write(out_dir.join("tokens.rs"), render_rust(&raw))
        .with_context(|| "writing generated Rust")?;

    let json_engine = out_dir.join("tokens.design.json");
    fs::write(&json_engine, serde_json::to_string_pretty(&raw)?).with_context(|| "writing JSON")?;

    let json_repo = manifest_dir.join("assets/design/tokens.json");
    fs::create_dir_all(json_repo.parent().unwrap())?;
    fs::copy(&json_engine, &json_repo).with_context(|| "copying JSON into assets/")?;

    Ok(())
}

#[derive(Debug, Serialize, Deserialize)]
struct RawTokens {
    color: Colors,
    spacing: Scale,
    radius: Scale,
    font: Font,
}

#[derive(Debug, Serialize, Deserialize)]
struct Colors {
    primary: String,
    primary_hover: String,
    text: String,
    surface: String,
    danger: String,
}

#[derive(Debug, Serialize, Deserialize)]
struct Scale {
    xs: f32,
    sm: f32,
    md: f32,
    lg: f32,
}

#[derive(Debug, Serialize, Deserialize)]
struct Font {
    family: String,
    size: FontSize,
}

#[derive(Debug, Serialize, Deserialize)]
struct FontSize {
    body: f32,
    h1: f32,
    h2: f32,
}

fn render_rust(raw: &RawTokens) -> String {
    let mut s = String::from("// ⚠️  @generated by build.rs – DO NOT EDIT.\n\n");

    // Colours
    s.push_str("pub struct Colour;\nimpl Colour {\n");
    s.push_str(&format!(
        "    pub const PRIMARY:       [f32;4] = {};\n",
        hex_to_vec4_literal(&raw.color.primary)
    ));
    s.push_str(&format!(
        "    pub const PRIMARY_HOVER: [f32;4] = {};\n",
        hex_to_vec4_literal(&raw.color.primary_hover)
    ));
    s.push_str(&format!(
        "    pub const SURFACE:       [f32;4] = {};\n",
        hex_to_vec4_literal(&raw.color.surface)
    ));
    s.push_str(&format!(
        "    pub const TEXT:          [f32;4] = {};\n",
        hex_to_vec4_literal(&raw.color.text)
    ));
    s.push_str(&format!(
        "    pub const DANGER:        [f32;4] = {};\n",
        hex_to_vec4_literal(&raw.color.danger)
    ));
    s.push_str("}\n\n");

    /* ---- Spacing ---- */
    s.push_str("pub struct Spacing;\nimpl Spacing {\n");
    s.push_str(&format!(
        "    pub const XS: f32 = {};\n",
        fmt_f32(raw.spacing.xs)
    ));
    s.push_str(&format!(
        "    pub const SM: f32 = {};\n",
        fmt_f32(raw.spacing.sm)
    ));
    s.push_str(&format!(
        "    pub const MD: f32 = {};\n",
        fmt_f32(raw.spacing.md)
    ));
    s.push_str(&format!(
        "    pub const LG: f32 = {};\n",
        fmt_f32(raw.spacing.lg)
    ));
    s.push_str("}\n\n");

    /* ---- Radius ---- */
    s.push_str("pub struct Radius;\nimpl Radius {\n");
    s.push_str("    pub const NONE: f32 = 0.0;\n");
    s.push_str(&format!(
        "    pub const SM: f32 = {};\n",
        fmt_f32(raw.radius.sm)
    ));
    s.push_str(&format!(
        "    pub const MD: f32 = {};\n",
        fmt_f32(raw.radius.md)
    ));
    s.push_str(&format!(
        "    pub const LG: f32 = {};\n",
        fmt_f32(raw.radius.lg)
    ));
    s.push_str("}\n\n");

    /* ---- Typography ---- */
    s.push_str("pub struct Typography;\nimpl Typography {\n");
    s.push_str(&format!(
        "    pub const FAMILY: &str = {:?};\n",
        raw.font.family
    ));
    s.push_str(&format!(
        "    pub const BODY: f32 = {};\n",
        fmt_f32(raw.font.size.body)
    ));
    s.push_str(&format!(
        "    pub const H1:   f32 = {};\n",
        fmt_f32(raw.font.size.h1)
    ));
    s.push_str(&format!(
        "    pub const H2:   f32 = {};\n",
        fmt_f32(raw.font.size.h2)
    ));
    s.push_str("}\n");

    s
}

fn fmt_f32<T: Into<f64>>(v: T) -> String {
    let n = v.into();
    if n.fract() == 0.0 {
        format!("{n}.0") // 2   -> "2.0"
    } else {
        format!("{n}") // 2.5 -> "2.5"
    }
}

fn hex_to_vec4_literal(hex: &str) -> String {
    let clean = hex.trim_start_matches('#');
    let (r, g, b, a) = match clean.len() {
        6 => {
            let r = u8::from_str_radix(&clean[0..2], 16).unwrap();
            let g = u8::from_str_radix(&clean[2..4], 16).unwrap();
            let b = u8::from_str_radix(&clean[4..6], 16).unwrap();
            (r, g, b, 255)
        }
        8 => {
            let r = u8::from_str_radix(&clean[0..2], 16).unwrap();
            let g = u8::from_str_radix(&clean[2..4], 16).unwrap();
            let b = u8::from_str_radix(&clean[4..6], 16).unwrap();
            let a = u8::from_str_radix(&clean[6..8], 16).unwrap();
            (r, g, b, a)
        }
        _ => panic!("invalid hex colour literal: {hex}"),
    };
    format!(
        "[{:.3}, {:.3}, {:.3}, {:.3}]",
        r as f32 / 255.0,
        g as f32 / 255.0,
        b as f32 / 255.0,
        a as f32 / 255.0
    )
}

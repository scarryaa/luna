use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};
use std::{env, fs, path::PathBuf};

const TOKENS_YAML: &str = "tokens.yaml";
const GENERATED_RS: &str = "tokens.rs";
const DESIGN_JSON: &str = "tokens.design.json";
const ASSETS_JSON: &str = "assets/design/tokens.json";

fn main() -> Result<()> {
    println!("cargo:rerun-if-changed={}", TOKENS_YAML);

    let manifest_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR")?);
    let out_dir = PathBuf::from(env::var("OUT_DIR")?);

    let yaml_src = fs::read_to_string(manifest_dir.join(TOKENS_YAML))
        .with_context(|| format!("reading {TOKENS_YAML}"))?;

    let raw: RawTokens =
        serde_yaml::from_str(&yaml_src).with_context(|| format!("parsing {TOKENS_YAML}"))?;

    // Write generated Rust
    let generated_rs_path = out_dir.join(GENERATED_RS);
    fs::write(&generated_rs_path, render_rust(&raw))
        .with_context(|| format!("writing generated Rust to {:?}", generated_rs_path))?;

    // Write JSON for engine
    let json_engine = out_dir.join(DESIGN_JSON);
    fs::write(&json_engine, serde_json::to_string_pretty(&raw)?)
        .with_context(|| format!("writing JSON to {:?}", json_engine))?;

    // Copy JSON to assets
    let json_repo = manifest_dir.join(ASSETS_JSON);
    if let Some(parent) = json_repo.parent() {
        fs::create_dir_all(parent).with_context(|| format!("creating directory {:?}", parent))?;
    }
    fs::copy(&json_engine, &json_repo)
        .with_context(|| format!("copying JSON into assets at {:?}", json_repo))?;

    Ok(())
}

#[derive(Debug, Serialize, Deserialize)]
struct RawTokens {
    color: Colors,
    spacing: Scale,
    radius: Scale,
    font: Font,
}

#[derive(Debug, Serialize, Deserialize)]
struct Colors {
    primary: String,
    primary_hover: String,
    text: String,
    surface: String,
    danger: String,
}

#[derive(Debug, Serialize, Deserialize)]
struct Scale {
    xs: f32,
    sm: f32,
    md: f32,
    lg: f32,
}

#[derive(Debug, Serialize, Deserialize)]
struct Font {
    family: String,
    size: FontSize,
}

#[derive(Debug, Serialize, Deserialize)]
struct FontSize {
    body: f32,
    h1: f32,
    h2: f32,
}

fn render_rust(raw: &RawTokens) -> String {
    let mut s = String::from("// ⚠️  @generated by build.rs – DO NOT EDIT.\n\n");

    // Colour Struct
    s.push_str(
        "#[derive(Debug, Clone, Copy)]\n\
         pub struct Colour {\n\
         \tpub primary: [f32; 4],\n\
         \tpub primary_hover: [f32; 4],\n\
         \tpub text: [f32; 4],\n\
         \tpub surface: [f32; 4],\n\
         \tpub danger: [f32; 4],\n\
         }\n\n",
    );

    // Spacing Struct
    s.push_str(
        "#[derive(Debug, Clone, Copy)]\n\
         pub struct Spacing {\n\
         \tpub xs: f32,\n\
         \tpub sm: f32,\n\
         \tpub md: f32,\n\
         \tpub lg: f32,\n\
         }\n\n",
    );

    // Radius Struct
    s.push_str(
        "#[derive(Debug, Clone, Copy)]\n\
         pub struct Radius {\n\
         \tpub none: f32,\n\
         \tpub sm: f32,\n\
         \tpub md: f32,\n\
         \tpub lg: f32,\n\
         }\n\n",
    );

    // Typography Struct
    s.push_str(
        "#[derive(Debug, Clone, Copy)]\n\
         pub struct Typography {\n\
         \tpub family: &'static str,\n\
         \tpub body: f32,\n\
         \tpub h1: f32,\n\
         \tpub h2: f32,\n\
         }\n\n",
    );

    // Top-level Theme Struct
    s.push_str(
        "#[derive(Debug, Clone, Copy)]\n\
         pub struct Theme {\n\
         \tpub color: Colour,\n\
         \tpub spacing: Spacing,\n\
         \tpub radius: Radius,\n\
         \tpub typography: Typography,\n\
         }\n\n",
    );

    s.push_str("impl Default for Theme {\n");
    s.push_str("\tfn default() -> Self {\n");
    s.push_str("\t\tSelf {\n");

    // Colour
    s.push_str("\t\t\tcolor: Colour {\n");
    s.push_str(&format!(
        "\t\t\t\tprimary:       {},\n",
        hex_to_vec4_literal(&raw.color.primary)
    ));
    s.push_str(&format!(
        "\t\t\t\tprimary_hover: {},\n",
        hex_to_vec4_literal(&raw.color.primary_hover)
    ));
    s.push_str(&format!(
        "\t\t\t\tsurface:       {},\n",
        hex_to_vec4_literal(&raw.color.surface)
    ));
    s.push_str(&format!(
        "\t\t\t\ttext:          {},\n",
        hex_to_vec4_literal(&raw.color.text)
    ));
    s.push_str(&format!(
        "\t\t\t\tdanger:        {},\n",
        hex_to_vec4_literal(&raw.color.danger)
    ));
    s.push_str("\t\t\t},\n");

    // Spacing
    s.push_str("\t\t\tspacing: Spacing {\n");
    s.push_str(&format!("\t\t\t\txs: {},\n", fmt_f32(raw.spacing.xs)));
    s.push_str(&format!("\t\t\t\tsm: {},\n", fmt_f32(raw.spacing.sm)));
    s.push_str(&format!("\t\t\t\tmd: {},\n", fmt_f32(raw.spacing.md)));
    s.push_str(&format!("\t\t\t\tlg: {},\n", fmt_f32(raw.spacing.lg)));
    s.push_str("\t\t\t},\n");

    // Radius
    s.push_str("\t\t\tradius: Radius {\n");
    s.push_str("\t\t\t\tnone: 0.0,\n");
    s.push_str(&format!("\t\t\t\tsm: {},\n", fmt_f32(raw.radius.sm)));
    s.push_str(&format!("\t\t\t\tmd: {},\n", fmt_f32(raw.radius.md)));
    s.push_str(&format!("\t\t\t\tlg: {},\n", fmt_f32(raw.radius.lg)));
    s.push_str("\t\t\t},\n");

    // Typography
    s.push_str("\t\t\ttypography: Typography {\n");
    s.push_str(&format!("\t\t\t\tfamily: {:?},\n", raw.font.family));
    s.push_str(&format!("\t\t\t\tbody: {},\n", fmt_f32(raw.font.size.body)));
    s.push_str(&format!("\t\t\t\th1: {},\n", fmt_f32(raw.font.size.h1)));
    s.push_str(&format!("\t\t\t\th2: {},\n", fmt_f32(raw.font.size.h2)));
    s.push_str("\t\t\t},\n");

    s.push_str("\t\t}\n");
    s.push_str("\t}\n");
    s.push_str("}\n");

    s
}

fn fmt_f32<T: Into<f64>>(v: T) -> String {
    let n = v.into();
    if n.fract() == 0.0 {
        format!("{n}.0")
    } else {
        format!("{n}")
    }
}

fn hex_to_vec4_literal(hex: &str) -> String {
    let clean = hex.trim_start_matches('#');
    let (r, g, b, a) = match clean.len() {
        6 => {
            let r = u8::from_str_radix(&clean[0..2], 16).unwrap();
            let g = u8::from_str_radix(&clean[2..4], 16).unwrap();
            let b = u8::from_str_radix(&clean[4..6], 16).unwrap();
            (r, g, b, 255)
        }
        8 => {
            let r = u8::from_str_radix(&clean[0..2], 16).unwrap();
            let g = u8::from_str_radix(&clean[2..4], 16).unwrap();
            let b = u8::from_str_radix(&clean[4..6], 16).unwrap();
            let a = u8::from_str_radix(&clean[6..8], 16).unwrap();
            (r, g, b, a)
        }
        _ => panic!("invalid hex colour literal: {hex}"),
    };
    format!(
        "[{:.3}, {:.3}, {:.3}, {:.3}]",
        r as f32 / 255.0,
        g as f32 / 255.0,
        b as f32 / 255.0,
        a as f32 / 255.0
    )
}
